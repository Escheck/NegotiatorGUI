/*
 * ProgressUI2.java
 *
 * Created on September 8, 2008, 3:24 PM
 */

package negotiator.gui.progress;

import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.TextArea;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import javax.swing.BorderFactory;
import javax.swing.JPanel;
import javax.swing.JTable;
import javax.swing.border.Border;
import javax.swing.border.EtchedBorder;
import javax.swing.table.DefaultTableModel;
import javax.swing.text.BadLocationException;

import negotiator.Bid;
import negotiator.BidIterator;
import negotiator.MultipartyNegotiationEventListener;
import negotiator.actions.Action;
import negotiator.actions.Offer;
import negotiator.events.LogMessageEvent;
import negotiator.events.MultipartyNegotiationOfferEvent;
import negotiator.events.MultipartySessionEndedEvent;
import negotiator.events.NegotiationEvent;
import negotiator.gui.chart.MultipartyBidChart;
import negotiator.parties.NegotiationPartyInternal;
import negotiator.protocol.MediatorProtocol;
import negotiator.session.Round;
import negotiator.session.Session;
import negotiator.utility.UtilitySpace;

import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;

@SuppressWarnings("serial")
public class MultipartyProgressUI extends javax.swing.JPanel implements
		MultipartyNegotiationEventListener {

	// about negotiation session
	private Session session;
	private List<NegotiationPartyInternal> parties;

	/******************** GUI FIELDS ******************/
	public static final int MAX_TEXT_OUTPUT = 100000; // 100K
	/** the table model at the bottom */
	private String[] progressTableInfo;
	private MultipartyBidChart bidChart;
	private TextArea logText;
	private JPanel chart;

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.JTable biddingTable;
	private javax.swing.JPanel jPanelNegoChart;
	private javax.swing.JPanel jPanelNegoLog;
	private javax.swing.JPanel jPanelNegoTable;
	private javax.swing.JScrollPane jScrollPaneNegoChart;
	private javax.swing.JScrollPane jScrollPaneNegoLog;
	private javax.swing.JScrollPane jScrollPaneNegoTable;
	private javax.swing.JSplitPane jSplitPane1;
	private javax.swing.JSplitPane jSplitPane2;
	private javax.swing.JSplitPane jSplitPane3;
	private javax.swing.JTextArea textOutput;

	// maximum utility history to keep for each session (absolute maximum is
	// int.max)
	public static final int MAX_UTIL_HISTORY = 100000; // 100K

	// holds a history of all the utilities for the agents. Used for plotting
	// purposes
	private List<List<Double[]>> turnAndUtilPerRoundPerAgent;

	/** Creates new form ProgressUI2 */
	public MultipartyProgressUI(ArrayList<String> partyInfo,
			List<NegotiationPartyInternal> parties) {

		this.parties = parties;

		this.turnAndUtilPerRoundPerAgent = new ArrayList<List<Double[]>>();
		// add a util list for each non-mediator agent
		// needed for reference (for indexing the parties)
		List<NegotiationPartyInternal> agents = MediatorProtocol
				.getNonMediators(parties);
		for (int i = 0; i < agents.size(); i++)
			turnAndUtilPerRoundPerAgent.add(new LinkedList<Double[]>());

		progressTableInfo = new String[partyInfo.size() + 1];
		progressTableInfo[0] = "Round";
		for (int i = 0; i < partyInfo.size(); i++)
			progressTableInfo[i + 1] = partyInfo.get(i);

		initComponents();
		bidChart = new MultipartyBidChart(partyInfo); // maximum round will be
														// given
		biddingTable.setGridColor(Color.lightGray);
		initializeProgressGUI("initialized...", bidChart, biddingTable);
	}

	private void initializeProgressGUI(String logging,
			MultipartyBidChart bidChart, JTable bidTable) {

		Container pane = jPanelNegoChart;
		pane.setLayout(new GridBagLayout());
		GridBagConstraints c = new GridBagConstraints();
		Border loweredetched = BorderFactory
				.createEtchedBorder(EtchedBorder.LOWERED);

		// the chart panel
		c.gridx = 1;
		c.gridy = 0;
		c.fill = GridBagConstraints.BOTH;
		JFreeChart plot = bidChart.getChart();
		chart = new ChartPanel(plot);
		chart.setMinimumSize(new Dimension(350, 350));
		chart.setBorder(loweredetched);
		c.insets = new Insets(10, 0, 0, 10);
		c.ipadx = 10;
		c.ipady = 10;
		pane.add(chart, c);

		jPanelNegoChart.add(chart);
		logText = new TextArea();
		logText.setText("");

	}

	// End of variables declaration//GEN-END:variables

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed"
	// desc="Generated Code">//GEN-BEGIN:initComponents
	private void initComponents() {

		jSplitPane2 = new javax.swing.JSplitPane();
		jSplitPane1 = new javax.swing.JSplitPane();
		jSplitPane3 = new javax.swing.JSplitPane();
		jPanelNegoChart = new javax.swing.JPanel();
		jScrollPaneNegoChart = new javax.swing.JScrollPane();
		jPanelNegoTable = new javax.swing.JPanel();
		jScrollPaneNegoTable = new javax.swing.JScrollPane();
		biddingTable = new javax.swing.JTable();
		jPanelNegoLog = new javax.swing.JPanel();
		jScrollPaneNegoLog = new javax.swing.JScrollPane();
		textOutput = new javax.swing.JTextArea();

		jSplitPane2.setName("jSplitPane2"); // NOI18N

		setName("Form"); // NOI18N

		jSplitPane1.setDividerSize(3);
		jSplitPane1.setName("jSplitPane1"); // NOI18N

		jSplitPane3.setDividerSize(3);
		jSplitPane3.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
		jSplitPane3.setName("jSplitPane3"); // NOI18N

		jPanelNegoChart.setBorder(javax.swing.BorderFactory
				.createTitledBorder("Negotiation dynamics chart"));
		jPanelNegoChart.setName("jPanelNegoChart"); // NOI18N

		jScrollPaneNegoChart.setName("jScrollPaneNegoChart"); // NOI18N

		org.jdesktop.layout.GroupLayout jPanelNegoChartLayout = new org.jdesktop.layout.GroupLayout(
				jPanelNegoChart);
		jPanelNegoChart.setLayout(jPanelNegoChartLayout);
		jPanelNegoChartLayout.setHorizontalGroup(jPanelNegoChartLayout
				.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
				.add(jPanelNegoChartLayout
						.createSequentialGroup()
						.addContainerGap()
						.add(jScrollPaneNegoChart,
								org.jdesktop.layout.GroupLayout.PREFERRED_SIZE,
								346,
								org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
						.addContainerGap(26, Short.MAX_VALUE)));
		jPanelNegoChartLayout.setVerticalGroup(jPanelNegoChartLayout
				.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
				.add(jPanelNegoChartLayout
						.createSequentialGroup()
						.addContainerGap()
						.add(jScrollPaneNegoChart,
								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
								71, Short.MAX_VALUE)));

		jSplitPane3.setTopComponent(jPanelNegoChart);

		jPanelNegoTable
				.setBorder(javax.swing.BorderFactory
						.createTitledBorder("Discounted utility of the proposed offers"));
		jPanelNegoTable.setName("jPanelNegoTable"); // NOI18N

		jScrollPaneNegoTable.setName("jScrollPaneNegoTable"); // NOI18N

		biddingTable.setModel(new javax.swing.table.DefaultTableModel(
				new Object[][] {}, progressTableInfo) {
			boolean[] canEdit = new boolean[progressTableInfo.length];

			public boolean isCellEditable(int rowIndex, int columnIndex) {
				return canEdit[columnIndex];
			}
		});

		biddingTable.setName("biddingTable"); // NOI18N
		jScrollPaneNegoTable.setViewportView(biddingTable);

		org.jdesktop.layout.GroupLayout jPanelNegoTableLayout = new org.jdesktop.layout.GroupLayout(
				jPanelNegoTable);
		jPanelNegoTable.setLayout(jPanelNegoTableLayout);
		jPanelNegoTableLayout.setHorizontalGroup(jPanelNegoTableLayout
				.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
				.add(jScrollPaneNegoTable,
						org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 382,
						Short.MAX_VALUE));
		jPanelNegoTableLayout.setVerticalGroup(jPanelNegoTableLayout
				.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
				.add(jScrollPaneNegoTable,
						org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 165,
						Short.MAX_VALUE));

		jSplitPane3.setRightComponent(jPanelNegoTable);
		org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application
				.getInstance().getContext()
				.getResourceMap(MultipartyProgressUI.class);
		jPanelNegoTable.getAccessibleContext().setAccessibleName(
				resourceMap
						.getString("jPanel3.AccessibleContext.accessibleName")); // NOI18N

		jSplitPane1.setRightComponent(jSplitPane3);

		jPanelNegoLog.setBorder(javax.swing.BorderFactory
				.createTitledBorder("Negotiation log"));
		jPanelNegoLog.setName("jPanelNegoLog"); // NOI18N

		jScrollPaneNegoLog.setName("jScrollPaneNegoLog"); // NOI18N

		textOutput.setColumns(20);
		textOutput.setRows(5);
		textOutput.setName("textLogOutput"); // NOI18N
		jScrollPaneNegoLog.setViewportView(textOutput);

		org.jdesktop.layout.GroupLayout jPanelNegoLogLayout = new org.jdesktop.layout.GroupLayout(
				jPanelNegoLog);
		jPanelNegoLog.setLayout(jPanelNegoLogLayout);
		jPanelNegoLogLayout.setHorizontalGroup(jPanelNegoLogLayout
				.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
				.add(jScrollPaneNegoLog,
						org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 81,
						Short.MAX_VALUE));
		jPanelNegoLogLayout.setVerticalGroup(jPanelNegoLogLayout
				.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
				.add(jScrollPaneNegoLog,
						org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 275,
						Short.MAX_VALUE));

		jSplitPane1.setLeftComponent(jPanelNegoLog);

		org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(
				this);
		this.setLayout(layout);
		layout.setHorizontalGroup(layout.createParallelGroup(
				org.jdesktop.layout.GroupLayout.LEADING).add(jSplitPane1,
				org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 494,
				Short.MAX_VALUE));
		layout.setVerticalGroup(layout.createParallelGroup(
				org.jdesktop.layout.GroupLayout.LEADING).add(jSplitPane1,
				org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 300,
				Short.MAX_VALUE));
	}// </editor-fold>//GEN-END:initComponents

	private void addRowBiddingTable(int round, int turn,
			List<Double> partyUtilities) {

		DefaultTableModel partyModel = (DefaultTableModel) biddingTable
				.getModel();
		Object[] currentBiddingObject = new Object[partyUtilities.size() + 1];

		currentBiddingObject[0] = round + turn / 10d;
		for (int i = 0; i < partyUtilities.size(); i++) {
			currentBiddingObject[i + 1] = partyUtilities.get(i);
		}

		partyModel.addRow(currentBiddingObject);
		if (partyModel.getRowCount() > MAX_TEXT_OUTPUT) {
			partyModel.removeRow(0);
		}

		biddingTable.setModel(partyModel);
	}

	private List<UtilitySpace> getUtilitySpaces() {
		List<UtilitySpace> spaces = new ArrayList<UtilitySpace>();
		for (NegotiationPartyInternal party : MediatorProtocol
				.getNonMediators(parties))
			spaces.add(party.getUtilitySpace());
		return spaces;
	}

	private void calculateNashProduct() throws Exception {

		double tempProduct = 1.0;
		Bid currentBid = null;
		BidIterator lBidIter = new BidIterator(getUtilitySpaces().get(0)
				.getDomain());

		while (lBidIter.hasNext()) {
			tempProduct = 1.0;

			currentBid = lBidIter.next();

			for (UtilitySpace utilitySpace : getUtilitySpaces())
				tempProduct *= utilitySpace.getUtility(currentBid);

			if (tempProduct > nashProduct) {
				nashProduct = tempProduct;
			}
		}
	}

	private double nashProduct = -1d;

	public double[][] getNashProduct(double roundRange) {
		try {
			if (nashProduct == -1d)
				calculateNashProduct();
		} catch (Exception e) {
			e.printStackTrace();
		}

		double[][] nashDataSeries = new double[2][2];
		nashDataSeries[0][0] = -1;
		nashDataSeries[1][0] = nashProduct;
		nashDataSeries[0][1] = roundRange + 2;
		nashDataSeries[1][1] = nashProduct;

		return nashDataSeries;
	}

	@Override
	public void handleEvent(NegotiationEvent e) {
		if (e instanceof LogMessageEvent) {
			handleLogMessageEvent((LogMessageEvent) e);
		} else if (e instanceof MultipartyNegotiationOfferEvent) {
			handleOffer((MultipartyNegotiationOfferEvent) e);
		} else if (e instanceof MultipartySessionEndedEvent) {
			sessionEnded((MultipartySessionEndedEvent) e);
		}
	}

	/**
	 * Handle reported offer
	 */
	private void handleOffer(MultipartyNegotiationOfferEvent e) {

		for (int agentId = 0; agentId < e.getPartyUtilities().size(); agentId++) {
			Double[] entry = { e.getRound() + e.getTurn() / 10d,
					e.getPartyUtilities().get(agentId) };
			if (turnAndUtilPerRoundPerAgent.get(0).size() < MAX_UTIL_HISTORY)
				turnAndUtilPerRoundPerAgent.get(agentId).add(entry);
		}
		addRowBiddingTable(e.getRound(), e.getTurn(), e.getPartyUtilities());
	}

	private void handleLogMessageEvent(LogMessageEvent evt) {
		textOutput.append(evt.getMessage() + "\n");
		if (textOutput.getLineCount() > MAX_TEXT_OUTPUT) {
			try {
				int end = textOutput.getLineEndOffset(0);
				textOutput.replaceRange("", 0, end);
			} catch (BadLocationException e) {
				e.printStackTrace();
			}
		}
		// writing log to session --> session.setLog(textOutput.getText());
	}

	private void sessionEnded(MultipartySessionEndedEvent evt) {
		session = evt.getSession();
		bidChart.setMaxRound(session.getRoundNumber() + 1);
		bidChart.setNashSeries(getNashProduct(session.getRoundNumber()));
		bidChart.setBidSeries(turnAndUtilPerRoundPerAgent);

		double[][] agreementUtilitiesDiscounted = bidPointsTable(evt);

		if (evt.getAgreement() != null) {
			bidChart.setAgreementPoints(agreementUtilitiesDiscounted);
		}
	}

	/**
	 * Create list for bid chart: round number and (discounted) utility value of
	 * agreement if any. If no agreement this function is undefined.
	 *
	 * result[0][0] = 2.1 <-- round number result[0][1] = 2.1 <-- round number
	 * result[1][0] = 0.40 <-- utility result[1][1] = 0.80 <-- utility
	 *
	 * @param evt
	 *            the {@link MultipartySessionEndedEvent}.
	 * @return The round number and utility of agreement if any.
	 */

	private double[][] bidPointsTable(MultipartySessionEndedEvent evt) {
		List<NegotiationPartyInternal> agents = evt.getParties();

		double[][] agreementUtilitiesDiscounted = new double[2][agents.size()];
		Bid agreement = evt.getAgreement();
		if (agreement != null) {
			for (NegotiationPartyInternal agent : agents) {
				int agentId = agents.indexOf(agent);
				double when = findLastIndexOfBid(agreement, session);
				Double[] entry = {
						Double.isNaN(when) ? session.getRoundNumber() : when,
						agent.getUtilityWithDiscount(agreement) };
				agreementUtilitiesDiscounted[0][agentId] = entry[0];
				agreementUtilitiesDiscounted[1][agentId] = entry[1];
			}
		}
		return agreementUtilitiesDiscounted;
	}

	/**
	 * @param needle
	 *            the bid you are looking for
	 * @param session
	 *            the session containing the round results.
	 * @return Finds the last index of the bid in the session or NaN if not
	 *         found
	 */
	private static double findLastIndexOfBid(Bid needle, Session session) {
		for (int roundIndex = session.getRounds().size() - 1; roundIndex >= 0; roundIndex--) {
			Round round = session.getRounds().get(roundIndex);
			for (int actionIndex = round.getActions().size() - 1; actionIndex >= 0; actionIndex--) {
				Action action = round.getActions().get(actionIndex);
				if (action instanceof Offer
						&& ((Offer) action).getBid().equals(needle))
					return (roundIndex + 1) + (actionIndex + 1) / 10d;
			}
		}
		return Double.NaN;
	}

}
